// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package api

import (
	"strconv"

	flatbuffers "github.com/google/flatbuffers/go"
)

type HandshakeVersion uint32

const (
	HandshakeVersionv1 HandshakeVersion = 0
	HandshakeVersionv2 HandshakeVersion = 1
)

var EnumNamesHandshakeVersion = map[HandshakeVersion]string{
	HandshakeVersionv1: "v1",
	HandshakeVersionv2: "v2",
}

var EnumValuesHandshakeVersion = map[string]HandshakeVersion{
	"v1": HandshakeVersionv1,
	"v2": HandshakeVersionv2,
}

func (v HandshakeVersion) String() string {
	if s, ok := EnumNamesHandshakeVersion[v]; ok {
		return s
	}
	return "HandshakeVersion(" + strconv.FormatInt(int64(v), 10) + ")"
}

type ProtocolVersion uint32

const (
	ProtocolVersionv1 ProtocolVersion = 0
	ProtocolVersionv2 ProtocolVersion = 1
)

var EnumNamesProtocolVersion = map[ProtocolVersion]string{
	ProtocolVersionv1: "v1",
	ProtocolVersionv2: "v2",
}

var EnumValuesProtocolVersion = map[string]ProtocolVersion{
	"v1": ProtocolVersionv1,
	"v2": ProtocolVersionv2,
}

func (v ProtocolVersion) String() string {
	if s, ok := EnumNamesProtocolVersion[v]; ok {
		return s
	}
	return "ProtocolVersion(" + strconv.FormatInt(int64(v), 10) + ")"
}

type UserActionType byte

const (
	UserActionTypeHighfive  UserActionType = 0
	UserActionTypeFireworks UserActionType = 1
	UserActionTypeSkybox    UserActionType = 2
)

var EnumNamesUserActionType = map[UserActionType]string{
	UserActionTypeHighfive:  "Highfive",
	UserActionTypeFireworks: "Fireworks",
	UserActionTypeSkybox:    "Skybox",
}

var EnumValuesUserActionType = map[string]UserActionType{
	"Highfive":  UserActionTypeHighfive,
	"Fireworks": UserActionTypeFireworks,
	"Skybox":    UserActionTypeSkybox,
}

func (v UserActionType) String() string {
	if s, ok := EnumNamesUserActionType[v]; ok {
		return s
	}
	return "UserActionType(" + strconv.FormatInt(int64(v), 10) + ")"
}

type WowType byte

const (
	WowTypePositive WowType = 0
	WowTypeNegative WowType = 1
)

var EnumNamesWowType = map[WowType]string{
	WowTypePositive: "Positive",
	WowTypeNegative: "Negative",
}

var EnumValuesWowType = map[string]WowType{
	"Positive": WowTypePositive,
	"Negative": WowTypeNegative,
}

func (v WowType) String() string {
	if s, ok := EnumNamesWowType[v]; ok {
		return s
	}
	return "WowType(" + strconv.FormatInt(int64(v), 10) + ")"
}

type ActionMetadata byte

const (
	ActionMetadataNONE              ActionMetadata = 0
	ActionMetadataFireworksMetadata ActionMetadata = 1
	ActionMetadataHighfiveMetadata  ActionMetadata = 2
	ActionMetadataWowMetadata       ActionMetadata = 3
)

var EnumNamesActionMetadata = map[ActionMetadata]string{
	ActionMetadataNONE:              "NONE",
	ActionMetadataFireworksMetadata: "FireworksMetadata",
	ActionMetadataHighfiveMetadata:  "HighfiveMetadata",
	ActionMetadataWowMetadata:       "WowMetadata",
}

var EnumValuesActionMetadata = map[string]ActionMetadata{
	"NONE":              ActionMetadataNONE,
	"FireworksMetadata": ActionMetadataFireworksMetadata,
	"HighfiveMetadata":  ActionMetadataHighfiveMetadata,
	"WowMetadata":       ActionMetadataWowMetadata,
}

func (v ActionMetadata) String() string {
	if s, ok := EnumNamesActionMetadata[v]; ok {
		return s
	}
	return "ActionMetadata(" + strconv.FormatInt(int64(v), 10) + ")"
}

type Msg byte

const (
	MsgNONE                Msg = 0
	MsgHandshake           Msg = 1
	MsgUserAction          Msg = 2
	MsgOn3DAction          Msg = 3
	MsgInteractonTrigger   Msg = 4
	MsgSetWorld            Msg = 5
	MsgObjectDefinition    Msg = 6
	MsgAddStaticObjects    Msg = 7
	MsgAddActiveObjects    Msg = 8
	MsgSetObjectTextures   Msg = 9
	MsgSetObjectStrings    Msg = 10
	MsgSetObjectAttributes Msg = 11
)

var EnumNamesMsg = map[Msg]string{
	MsgNONE:                "NONE",
	MsgHandshake:           "Handshake",
	MsgUserAction:          "UserAction",
	MsgOn3DAction:          "On3DAction",
	MsgInteractonTrigger:   "InteractonTrigger",
	MsgSetWorld:            "SetWorld",
	MsgObjectDefinition:    "ObjectDefinition",
	MsgAddStaticObjects:    "AddStaticObjects",
	MsgAddActiveObjects:    "AddActiveObjects",
	MsgSetObjectTextures:   "SetObjectTextures",
	MsgSetObjectStrings:    "SetObjectStrings",
	MsgSetObjectAttributes: "SetObjectAttributes",
}

var EnumValuesMsg = map[string]Msg{
	"NONE":                MsgNONE,
	"Handshake":           MsgHandshake,
	"UserAction":          MsgUserAction,
	"On3DAction":          MsgOn3DAction,
	"InteractonTrigger":   MsgInteractonTrigger,
	"SetWorld":            MsgSetWorld,
	"ObjectDefinition":    MsgObjectDefinition,
	"AddStaticObjects":    MsgAddStaticObjects,
	"AddActiveObjects":    MsgAddActiveObjects,
	"SetObjectTextures":   MsgSetObjectTextures,
	"SetObjectStrings":    MsgSetObjectStrings,
	"SetObjectAttributes": MsgSetObjectAttributes,
}

func (v Msg) String() string {
	if s, ok := EnumNamesMsg[v]; ok {
		return s
	}
	return "Msg(" + strconv.FormatInt(int64(v), 10) + ")"
}

type Vec3 struct {
	_tab flatbuffers.Struct
}

func (rcv *Vec3) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Vec3) Table() flatbuffers.Table {
	return rcv._tab.Table
}

func (rcv *Vec3) X() float32 {
	return rcv._tab.GetFloat32(rcv._tab.Pos + flatbuffers.UOffsetT(0))
}
func (rcv *Vec3) MutateX(n float32) bool {
	return rcv._tab.MutateFloat32(rcv._tab.Pos+flatbuffers.UOffsetT(0), n)
}

func (rcv *Vec3) Y() float32 {
	return rcv._tab.GetFloat32(rcv._tab.Pos + flatbuffers.UOffsetT(4))
}
func (rcv *Vec3) MutateY(n float32) bool {
	return rcv._tab.MutateFloat32(rcv._tab.Pos+flatbuffers.UOffsetT(4), n)
}

func (rcv *Vec3) Z() float32 {
	return rcv._tab.GetFloat32(rcv._tab.Pos + flatbuffers.UOffsetT(8))
}
func (rcv *Vec3) MutateZ(n float32) bool {
	return rcv._tab.MutateFloat32(rcv._tab.Pos+flatbuffers.UOffsetT(8), n)
}

func CreateVec3(builder *flatbuffers.Builder, x float32, y float32, z float32) flatbuffers.UOffsetT {
	builder.Prep(4, 12)
	builder.PrependFloat32(z)
	builder.PrependFloat32(y)
	builder.PrependFloat32(x)
	return builder.Offset()
}
type PosRot struct {
	_tab flatbuffers.Struct
}

func (rcv *PosRot) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *PosRot) Table() flatbuffers.Table {
	return rcv._tab.Table
}

func (rcv *PosRot) Pos(obj *Vec3) *Vec3 {
	if obj == nil {
		obj = new(Vec3)
	}
	obj.Init(rcv._tab.Bytes, rcv._tab.Pos+0)
	return obj
}
func (rcv *PosRot) Rot(obj *Vec3) *Vec3 {
	if obj == nil {
		obj = new(Vec3)
	}
	obj.Init(rcv._tab.Bytes, rcv._tab.Pos+12)
	return obj
}

func CreatePosRot(builder *flatbuffers.Builder, pos_x float32, pos_y float32, pos_z float32, rot_x float32, rot_y float32, rot_z float32) flatbuffers.UOffsetT {
	builder.Prep(4, 24)
	builder.Prep(4, 12)
	builder.PrependFloat32(rot_z)
	builder.PrependFloat32(rot_y)
	builder.PrependFloat32(rot_x)
	builder.Prep(4, 12)
	builder.PrependFloat32(pos_z)
	builder.PrependFloat32(pos_y)
	builder.PrependFloat32(pos_x)
	return builder.Offset()
}
type ID struct {
	_tab flatbuffers.Struct
}

func (rcv *ID) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ID) Table() flatbuffers.Table {
	return rcv._tab.Table
}

func (rcv *ID) L() uint64 {
	return rcv._tab.GetUint64(rcv._tab.Pos + flatbuffers.UOffsetT(0))
}
func (rcv *ID) MutateL(n uint64) bool {
	return rcv._tab.MutateUint64(rcv._tab.Pos+flatbuffers.UOffsetT(0), n)
}

func (rcv *ID) M() uint64 {
	return rcv._tab.GetUint64(rcv._tab.Pos + flatbuffers.UOffsetT(8))
}
func (rcv *ID) MutateM(n uint64) bool {
	return rcv._tab.MutateUint64(rcv._tab.Pos+flatbuffers.UOffsetT(8), n)
}

func CreateID(builder *flatbuffers.Builder, l uint64, m uint64) flatbuffers.UOffsetT {
	builder.Prep(8, 16)
	builder.PrependUint64(m)
	builder.PrependUint64(l)
	return builder.Offset()
}
type TextureDefinition struct {
	_tab flatbuffers.Table
}

func GetRootAsTextureDefinition(buf []byte, offset flatbuffers.UOffsetT) *TextureDefinition {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &TextureDefinition{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsTextureDefinition(buf []byte, offset flatbuffers.UOffsetT) *TextureDefinition {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &TextureDefinition{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *TextureDefinition) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *TextureDefinition) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *TextureDefinition) Label() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *TextureDefinition) Data() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func TextureDefinitionStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func TextureDefinitionAddLabel(builder *flatbuffers.Builder, label flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(label), 0)
}
func TextureDefinitionAddData(builder *flatbuffers.Builder, data flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(data), 0)
}
func TextureDefinitionEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type StringDefinition struct {
	_tab flatbuffers.Table
}

func GetRootAsStringDefinition(buf []byte, offset flatbuffers.UOffsetT) *StringDefinition {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &StringDefinition{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsStringDefinition(buf []byte, offset flatbuffers.UOffsetT) *StringDefinition {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &StringDefinition{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *StringDefinition) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *StringDefinition) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *StringDefinition) Label() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *StringDefinition) Data() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func StringDefinitionStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func StringDefinitionAddLabel(builder *flatbuffers.Builder, label flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(label), 0)
}
func StringDefinitionAddData(builder *flatbuffers.Builder, data flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(data), 0)
}
func StringDefinitionEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type AttributeDefinition struct {
	_tab flatbuffers.Table
}

func GetRootAsAttributeDefinition(buf []byte, offset flatbuffers.UOffsetT) *AttributeDefinition {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &AttributeDefinition{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsAttributeDefinition(buf []byte, offset flatbuffers.UOffsetT) *AttributeDefinition {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &AttributeDefinition{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *AttributeDefinition) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *AttributeDefinition) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *AttributeDefinition) Label() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *AttributeDefinition) Attribute() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *AttributeDefinition) MutateAttribute(n int32) bool {
	return rcv._tab.MutateInt32Slot(6, n)
}

func AttributeDefinitionStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func AttributeDefinitionAddLabel(builder *flatbuffers.Builder, label flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(label), 0)
}
func AttributeDefinitionAddAttribute(builder *flatbuffers.Builder, attribute int32) {
	builder.PrependInt32Slot(1, attribute, 0)
}
func AttributeDefinitionEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Handshake struct {
	_tab flatbuffers.Table
}

func GetRootAsHandshake(buf []byte, offset flatbuffers.UOffsetT) *Handshake {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Handshake{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsHandshake(buf []byte, offset flatbuffers.UOffsetT) *Handshake {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &Handshake{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *Handshake) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Handshake) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Handshake) HandshakeVersion() HandshakeVersion {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return HandshakeVersion(rcv._tab.GetUint32(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *Handshake) MutateHandshakeVersion(n HandshakeVersion) bool {
	return rcv._tab.MutateUint32Slot(4, uint32(n))
}

func (rcv *Handshake) ProtocolVersion() ProtocolVersion {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return ProtocolVersion(rcv._tab.GetUint32(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *Handshake) MutateProtocolVersion(n ProtocolVersion) bool {
	return rcv._tab.MutateUint32Slot(6, uint32(n))
}

func (rcv *Handshake) UserToken() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Handshake) UserId(obj *ID) *ID {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		x := o + rcv._tab.Pos
		if obj == nil {
			obj = new(ID)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *Handshake) SessionId(obj *ID) *ID {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		x := o + rcv._tab.Pos
		if obj == nil {
			obj = new(ID)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *Handshake) Url() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func HandshakeStart(builder *flatbuffers.Builder) {
	builder.StartObject(6)
}
func HandshakeAddHandshakeVersion(builder *flatbuffers.Builder, handshakeVersion HandshakeVersion) {
	builder.PrependUint32Slot(0, uint32(handshakeVersion), 0)
}
func HandshakeAddProtocolVersion(builder *flatbuffers.Builder, protocolVersion ProtocolVersion) {
	builder.PrependUint32Slot(1, uint32(protocolVersion), 0)
}
func HandshakeAddUserToken(builder *flatbuffers.Builder, userToken flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(userToken), 0)
}
func HandshakeAddUserId(builder *flatbuffers.Builder, userId flatbuffers.UOffsetT) {
	builder.PrependStructSlot(3, flatbuffers.UOffsetT(userId), 0)
}
func HandshakeAddSessionId(builder *flatbuffers.Builder, sessionId flatbuffers.UOffsetT) {
	builder.PrependStructSlot(4, flatbuffers.UOffsetT(sessionId), 0)
}
func HandshakeAddUrl(builder *flatbuffers.Builder, url flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(url), 0)
}
func HandshakeEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type UserAction struct {
	_tab flatbuffers.Table
}

func GetRootAsUserAction(buf []byte, offset flatbuffers.UOffsetT) *UserAction {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &UserAction{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsUserAction(buf []byte, offset flatbuffers.UOffsetT) *UserAction {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &UserAction{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *UserAction) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *UserAction) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *UserAction) Type() UserActionType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return UserActionType(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *UserAction) MutateType(n UserActionType) bool {
	return rcv._tab.MutateByteSlot(4, byte(n))
}

func UserActionStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func UserActionAddType(builder *flatbuffers.Builder, type_ UserActionType) {
	builder.PrependByteSlot(0, byte(type_), 0)
}
func UserActionEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type FireworksMetadata struct {
	_tab flatbuffers.Table
}

func GetRootAsFireworksMetadata(buf []byte, offset flatbuffers.UOffsetT) *FireworksMetadata {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &FireworksMetadata{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsFireworksMetadata(buf []byte, offset flatbuffers.UOffsetT) *FireworksMetadata {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &FireworksMetadata{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *FireworksMetadata) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *FireworksMetadata) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *FireworksMetadata) Position(obj *Vec3) *Vec3 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := o + rcv._tab.Pos
		if obj == nil {
			obj = new(Vec3)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func FireworksMetadataStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func FireworksMetadataAddPosition(builder *flatbuffers.Builder, position flatbuffers.UOffsetT) {
	builder.PrependStructSlot(0, flatbuffers.UOffsetT(position), 0)
}
func FireworksMetadataEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type HighfiveMetadata struct {
	_tab flatbuffers.Table
}

func GetRootAsHighfiveMetadata(buf []byte, offset flatbuffers.UOffsetT) *HighfiveMetadata {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &HighfiveMetadata{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsHighfiveMetadata(buf []byte, offset flatbuffers.UOffsetT) *HighfiveMetadata {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &HighfiveMetadata{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *HighfiveMetadata) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *HighfiveMetadata) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *HighfiveMetadata) User1(obj *ID) *ID {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := o + rcv._tab.Pos
		if obj == nil {
			obj = new(ID)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *HighfiveMetadata) User2(obj *ID) *ID {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := o + rcv._tab.Pos
		if obj == nil {
			obj = new(ID)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func HighfiveMetadataStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func HighfiveMetadataAddUser1(builder *flatbuffers.Builder, user1 flatbuffers.UOffsetT) {
	builder.PrependStructSlot(0, flatbuffers.UOffsetT(user1), 0)
}
func HighfiveMetadataAddUser2(builder *flatbuffers.Builder, user2 flatbuffers.UOffsetT) {
	builder.PrependStructSlot(1, flatbuffers.UOffsetT(user2), 0)
}
func HighfiveMetadataEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type WowMetadata struct {
	_tab flatbuffers.Table
}

func GetRootAsWowMetadata(buf []byte, offset flatbuffers.UOffsetT) *WowMetadata {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &WowMetadata{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsWowMetadata(buf []byte, offset flatbuffers.UOffsetT) *WowMetadata {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &WowMetadata{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *WowMetadata) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *WowMetadata) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *WowMetadata) StructureId(obj *ID) *ID {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := o + rcv._tab.Pos
		if obj == nil {
			obj = new(ID)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *WowMetadata) Type() WowType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return WowType(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *WowMetadata) MutateType(n WowType) bool {
	return rcv._tab.MutateByteSlot(6, byte(n))
}

func WowMetadataStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func WowMetadataAddStructureId(builder *flatbuffers.Builder, structureId flatbuffers.UOffsetT) {
	builder.PrependStructSlot(0, flatbuffers.UOffsetT(structureId), 0)
}
func WowMetadataAddType(builder *flatbuffers.Builder, type_ WowType) {
	builder.PrependByteSlot(1, byte(type_), 0)
}
func WowMetadataEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type On3DAction struct {
	_tab flatbuffers.Table
}

func GetRootAsOn3DAction(buf []byte, offset flatbuffers.UOffsetT) *On3DAction {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &On3DAction{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsOn3DAction(buf []byte, offset flatbuffers.UOffsetT) *On3DAction {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &On3DAction{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *On3DAction) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *On3DAction) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *On3DAction) Type() UserActionType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return UserActionType(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *On3DAction) MutateType(n UserActionType) bool {
	return rcv._tab.MutateByteSlot(4, byte(n))
}

func (rcv *On3DAction) DataType() ActionMetadata {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return ActionMetadata(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *On3DAction) MutateDataType(n ActionMetadata) bool {
	return rcv._tab.MutateByteSlot(6, byte(n))
}

func (rcv *On3DAction) Data(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func On3DActionStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func On3DActionAddType(builder *flatbuffers.Builder, type_ UserActionType) {
	builder.PrependByteSlot(0, byte(type_), 0)
}
func On3DActionAddDataType(builder *flatbuffers.Builder, dataType ActionMetadata) {
	builder.PrependByteSlot(1, byte(dataType), 0)
}
func On3DActionAddData(builder *flatbuffers.Builder, data flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(data), 0)
}
func On3DActionEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type SetObjectTextures struct {
	_tab flatbuffers.Table
}

func GetRootAsSetObjectTextures(buf []byte, offset flatbuffers.UOffsetT) *SetObjectTextures {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &SetObjectTextures{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsSetObjectTextures(buf []byte, offset flatbuffers.UOffsetT) *SetObjectTextures {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &SetObjectTextures{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *SetObjectTextures) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *SetObjectTextures) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *SetObjectTextures) ObjectId(obj *ID) *ID {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := o + rcv._tab.Pos
		if obj == nil {
			obj = new(ID)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *SetObjectTextures) Objects(obj *TextureDefinition, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *SetObjectTextures) ObjectsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func SetObjectTexturesStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func SetObjectTexturesAddObjectId(builder *flatbuffers.Builder, objectId flatbuffers.UOffsetT) {
	builder.PrependStructSlot(0, flatbuffers.UOffsetT(objectId), 0)
}
func SetObjectTexturesAddObjects(builder *flatbuffers.Builder, objects flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(objects), 0)
}
func SetObjectTexturesStartObjectsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func SetObjectTexturesEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type SetObjectStrings struct {
	_tab flatbuffers.Table
}

func GetRootAsSetObjectStrings(buf []byte, offset flatbuffers.UOffsetT) *SetObjectStrings {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &SetObjectStrings{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsSetObjectStrings(buf []byte, offset flatbuffers.UOffsetT) *SetObjectStrings {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &SetObjectStrings{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *SetObjectStrings) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *SetObjectStrings) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *SetObjectStrings) ObjectId(obj *ID) *ID {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := o + rcv._tab.Pos
		if obj == nil {
			obj = new(ID)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *SetObjectStrings) Objects(obj *StringDefinition, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *SetObjectStrings) ObjectsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func SetObjectStringsStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func SetObjectStringsAddObjectId(builder *flatbuffers.Builder, objectId flatbuffers.UOffsetT) {
	builder.PrependStructSlot(0, flatbuffers.UOffsetT(objectId), 0)
}
func SetObjectStringsAddObjects(builder *flatbuffers.Builder, objects flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(objects), 0)
}
func SetObjectStringsStartObjectsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func SetObjectStringsEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type InteractonTrigger struct {
	_tab flatbuffers.Table
}

func GetRootAsInteractonTrigger(buf []byte, offset flatbuffers.UOffsetT) *InteractonTrigger {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &InteractonTrigger{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsInteractonTrigger(buf []byte, offset flatbuffers.UOffsetT) *InteractonTrigger {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &InteractonTrigger{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *InteractonTrigger) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *InteractonTrigger) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *InteractonTrigger) SpaceId(obj *ID) *ID {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := o + rcv._tab.Pos
		if obj == nil {
			obj = new(ID)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *InteractonTrigger) Label() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *InteractonTrigger) Metadata() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func InteractonTriggerStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func InteractonTriggerAddSpaceId(builder *flatbuffers.Builder, spaceId flatbuffers.UOffsetT) {
	builder.PrependStructSlot(0, flatbuffers.UOffsetT(spaceId), 0)
}
func InteractonTriggerAddLabel(builder *flatbuffers.Builder, label flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(label), 0)
}
func InteractonTriggerAddMetadata(builder *flatbuffers.Builder, metadata flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(metadata), 0)
}
func InteractonTriggerEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type DecorationMetadata struct {
	_tab flatbuffers.Table
}

func GetRootAsDecorationMetadata(buf []byte, offset flatbuffers.UOffsetT) *DecorationMetadata {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &DecorationMetadata{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsDecorationMetadata(buf []byte, offset flatbuffers.UOffsetT) *DecorationMetadata {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &DecorationMetadata{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *DecorationMetadata) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *DecorationMetadata) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *DecorationMetadata) AssetId(obj *ID) *ID {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := o + rcv._tab.Pos
		if obj == nil {
			obj = new(ID)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *DecorationMetadata) Pos(obj *PosRot) *PosRot {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := o + rcv._tab.Pos
		if obj == nil {
			obj = new(PosRot)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func DecorationMetadataStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func DecorationMetadataAddAssetId(builder *flatbuffers.Builder, assetId flatbuffers.UOffsetT) {
	builder.PrependStructSlot(0, flatbuffers.UOffsetT(assetId), 0)
}
func DecorationMetadataAddPos(builder *flatbuffers.Builder, pos flatbuffers.UOffsetT) {
	builder.PrependStructSlot(1, flatbuffers.UOffsetT(pos), 0)
}
func DecorationMetadataEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type SetWorld struct {
	_tab flatbuffers.Table
}

func GetRootAsSetWorld(buf []byte, offset flatbuffers.UOffsetT) *SetWorld {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &SetWorld{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsSetWorld(buf []byte, offset flatbuffers.UOffsetT) *SetWorld {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &SetWorld{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *SetWorld) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *SetWorld) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *SetWorld) WorldId(obj *ID) *ID {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := o + rcv._tab.Pos
		if obj == nil {
			obj = new(ID)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *SetWorld) Name() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *SetWorld) AvatarControllerId(obj *ID) *ID {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		x := o + rcv._tab.Pos
		if obj == nil {
			obj = new(ID)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *SetWorld) SkyboxControllerId(obj *ID) *ID {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		x := o + rcv._tab.Pos
		if obj == nil {
			obj = new(ID)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *SetWorld) LodDistances(j int) uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetUint32(a + flatbuffers.UOffsetT(j*4))
	}
	return 0
}

func (rcv *SetWorld) LodDistancesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *SetWorld) MutateLodDistances(j int, n uint32) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateUint32(a+flatbuffers.UOffsetT(j*4), n)
	}
	return false
}

func (rcv *SetWorld) Decorations(obj *DecorationMetadata, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *SetWorld) DecorationsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func SetWorldStart(builder *flatbuffers.Builder) {
	builder.StartObject(6)
}
func SetWorldAddWorldId(builder *flatbuffers.Builder, worldId flatbuffers.UOffsetT) {
	builder.PrependStructSlot(0, flatbuffers.UOffsetT(worldId), 0)
}
func SetWorldAddName(builder *flatbuffers.Builder, name flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(name), 0)
}
func SetWorldAddAvatarControllerId(builder *flatbuffers.Builder, avatarControllerId flatbuffers.UOffsetT) {
	builder.PrependStructSlot(2, flatbuffers.UOffsetT(avatarControllerId), 0)
}
func SetWorldAddSkyboxControllerId(builder *flatbuffers.Builder, skyboxControllerId flatbuffers.UOffsetT) {
	builder.PrependStructSlot(3, flatbuffers.UOffsetT(skyboxControllerId), 0)
}
func SetWorldAddLodDistances(builder *flatbuffers.Builder, lodDistances flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(lodDistances), 0)
}
func SetWorldStartLodDistancesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func SetWorldAddDecorations(builder *flatbuffers.Builder, decorations flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(decorations), 0)
}
func SetWorldStartDecorationsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func SetWorldEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type ObjectDefinition struct {
	_tab flatbuffers.Table
}

func GetRootAsObjectDefinition(buf []byte, offset flatbuffers.UOffsetT) *ObjectDefinition {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ObjectDefinition{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsObjectDefinition(buf []byte, offset flatbuffers.UOffsetT) *ObjectDefinition {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ObjectDefinition{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *ObjectDefinition) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ObjectDefinition) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ObjectDefinition) ObjectId(obj *ID) *ID {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := o + rcv._tab.Pos
		if obj == nil {
			obj = new(ID)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *ObjectDefinition) Name() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ObjectDefinition) Position(obj *Vec3) *Vec3 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		x := o + rcv._tab.Pos
		if obj == nil {
			obj = new(Vec3)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *ObjectDefinition) ParentId(obj *ID) *ID {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		x := o + rcv._tab.Pos
		if obj == nil {
			obj = new(ID)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *ObjectDefinition) AssetType(obj *ID) *ID {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		x := o + rcv._tab.Pos
		if obj == nil {
			obj = new(ID)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *ObjectDefinition) TetheredToParent() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *ObjectDefinition) MutateTetheredToParent(n bool) bool {
	return rcv._tab.MutateBoolSlot(14, n)
}

func (rcv *ObjectDefinition) Minimap() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *ObjectDefinition) MutateMinimap(n bool) bool {
	return rcv._tab.MutateBoolSlot(16, n)
}

func (rcv *ObjectDefinition) InfouiType(obj *ID) *ID {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		x := o + rcv._tab.Pos
		if obj == nil {
			obj = new(ID)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func ObjectDefinitionStart(builder *flatbuffers.Builder) {
	builder.StartObject(8)
}
func ObjectDefinitionAddObjectId(builder *flatbuffers.Builder, objectId flatbuffers.UOffsetT) {
	builder.PrependStructSlot(0, flatbuffers.UOffsetT(objectId), 0)
}
func ObjectDefinitionAddName(builder *flatbuffers.Builder, name flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(name), 0)
}
func ObjectDefinitionAddPosition(builder *flatbuffers.Builder, position flatbuffers.UOffsetT) {
	builder.PrependStructSlot(2, flatbuffers.UOffsetT(position), 0)
}
func ObjectDefinitionAddParentId(builder *flatbuffers.Builder, parentId flatbuffers.UOffsetT) {
	builder.PrependStructSlot(3, flatbuffers.UOffsetT(parentId), 0)
}
func ObjectDefinitionAddAssetType(builder *flatbuffers.Builder, assetType flatbuffers.UOffsetT) {
	builder.PrependStructSlot(4, flatbuffers.UOffsetT(assetType), 0)
}
func ObjectDefinitionAddTetheredToParent(builder *flatbuffers.Builder, tetheredToParent bool) {
	builder.PrependBoolSlot(5, tetheredToParent, false)
}
func ObjectDefinitionAddMinimap(builder *flatbuffers.Builder, minimap bool) {
	builder.PrependBoolSlot(6, minimap, false)
}
func ObjectDefinitionAddInfouiType(builder *flatbuffers.Builder, infouiType flatbuffers.UOffsetT) {
	builder.PrependStructSlot(7, flatbuffers.UOffsetT(infouiType), 0)
}
func ObjectDefinitionEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type AddStaticObjects struct {
	_tab flatbuffers.Table
}

func GetRootAsAddStaticObjects(buf []byte, offset flatbuffers.UOffsetT) *AddStaticObjects {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &AddStaticObjects{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsAddStaticObjects(buf []byte, offset flatbuffers.UOffsetT) *AddStaticObjects {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &AddStaticObjects{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *AddStaticObjects) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *AddStaticObjects) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *AddStaticObjects) Objects(obj *ObjectDefinition, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *AddStaticObjects) ObjectsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func AddStaticObjectsStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func AddStaticObjectsAddObjects(builder *flatbuffers.Builder, objects flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(objects), 0)
}
func AddStaticObjectsStartObjectsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func AddStaticObjectsEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type ActiveObjectMetadata struct {
	_tab flatbuffers.Table
}

func GetRootAsActiveObjectMetadata(buf []byte, offset flatbuffers.UOffsetT) *ActiveObjectMetadata {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ActiveObjectMetadata{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsActiveObjectMetadata(buf []byte, offset flatbuffers.UOffsetT) *ActiveObjectMetadata {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ActiveObjectMetadata{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *ActiveObjectMetadata) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ActiveObjectMetadata) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ActiveObjectMetadata) Id(obj *ID) *ID {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := o + rcv._tab.Pos
		if obj == nil {
			obj = new(ID)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *ActiveObjectMetadata) Type(obj *ID) *ID {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := o + rcv._tab.Pos
		if obj == nil {
			obj = new(ID)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *ActiveObjectMetadata) Meta() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func ActiveObjectMetadataStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func ActiveObjectMetadataAddId(builder *flatbuffers.Builder, id flatbuffers.UOffsetT) {
	builder.PrependStructSlot(0, flatbuffers.UOffsetT(id), 0)
}
func ActiveObjectMetadataAddType(builder *flatbuffers.Builder, type_ flatbuffers.UOffsetT) {
	builder.PrependStructSlot(1, flatbuffers.UOffsetT(type_), 0)
}
func ActiveObjectMetadataAddMeta(builder *flatbuffers.Builder, meta flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(meta), 0)
}
func ActiveObjectMetadataEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type AddActiveObjects struct {
	_tab flatbuffers.Table
}

func GetRootAsAddActiveObjects(buf []byte, offset flatbuffers.UOffsetT) *AddActiveObjects {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &AddActiveObjects{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsAddActiveObjects(buf []byte, offset flatbuffers.UOffsetT) *AddActiveObjects {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &AddActiveObjects{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *AddActiveObjects) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *AddActiveObjects) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *AddActiveObjects) Objects(obj *ActiveObjectMetadata, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *AddActiveObjects) ObjectsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func AddActiveObjectsStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func AddActiveObjectsAddObjects(builder *flatbuffers.Builder, objects flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(objects), 0)
}
func AddActiveObjectsStartObjectsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func AddActiveObjectsEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type SetObjectAttributes struct {
	_tab flatbuffers.Table
}

func GetRootAsSetObjectAttributes(buf []byte, offset flatbuffers.UOffsetT) *SetObjectAttributes {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &SetObjectAttributes{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsSetObjectAttributes(buf []byte, offset flatbuffers.UOffsetT) *SetObjectAttributes {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &SetObjectAttributes{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *SetObjectAttributes) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *SetObjectAttributes) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *SetObjectAttributes) SpaceId(obj *ID) *ID {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := o + rcv._tab.Pos
		if obj == nil {
			obj = new(ID)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *SetObjectAttributes) Objects(obj *AttributeDefinition, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *SetObjectAttributes) ObjectsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func SetObjectAttributesStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func SetObjectAttributesAddSpaceId(builder *flatbuffers.Builder, spaceId flatbuffers.UOffsetT) {
	builder.PrependStructSlot(0, flatbuffers.UOffsetT(spaceId), 0)
}
func SetObjectAttributesAddObjects(builder *flatbuffers.Builder, objects flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(objects), 0)
}
func SetObjectAttributesStartObjectsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func SetObjectAttributesEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type FlatBuffMsg struct {
	_tab flatbuffers.Table
}

func GetRootAsFlatBuffMsg(buf []byte, offset flatbuffers.UOffsetT) *FlatBuffMsg {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &FlatBuffMsg{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsFlatBuffMsg(buf []byte, offset flatbuffers.UOffsetT) *FlatBuffMsg {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &FlatBuffMsg{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *FlatBuffMsg) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *FlatBuffMsg) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *FlatBuffMsg) MsgType() Msg {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return Msg(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *FlatBuffMsg) MutateMsgType(n Msg) bool {
	return rcv._tab.MutateByteSlot(4, byte(n))
}

func (rcv *FlatBuffMsg) Msg(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func FlatBuffMsgStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func FlatBuffMsgAddMsgType(builder *flatbuffers.Builder, msgType Msg) {
	builder.PrependByteSlot(0, byte(msgType), 0)
}
func FlatBuffMsgAddMsg(builder *flatbuffers.Builder, msg flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(msg), 0)
}
func FlatBuffMsgEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
